def get_subdir_list(path):
    # Возвращает список подпапок, находящихся в указанной папке (не рекурсивный поиск)
    # path == полный или относительный путь до папки

def get_file_list_by_ext(path, ext, sort=False):
    # Возвращает список файлов, на ходящихся в указанной папке 'path', имена которых заканчиваются на строку указанную в параметре 'ext'
    # Доступна опция сортировки списка
    # path == полный или относительный путь до папки с файлами

def group_files_by_count(file_list, files_in_group=4):
    # Принимает на вход список файлов и количество файлов в группе (опционально)
    # Разбивает файлы по группам (последоватально)
    # Возвращает список групп, где группа == список:
    # [[file1, file2, file3, file4], [file5, file6, file7, file8], ... etc.]
    # Если количество файлов не делится нацело на files_in_group генерируется исключение

def group_files_lecroy(file_list, files_in_group=4):
    # Принимает на вход список файлов и количество файлов в группе (опционально)
    # Разбивает файлы по группам: к первой группе c номером i относятся файлы с номерами i, N+i, 2*N+i ... files_in_group*N+i
    # Где N == количество выстрелов (групп): N = len(file_list) / files_in_group
    # Возвращает список групп, где группа == список:
    # [[file1, file2, file3, file4], [file5, file6, file7, file8], ... etc.]
    # Если количество файлов не делится нацело на files_in_group генерируется исключение

def get_name_from_group_of_files(group, ch_postfix_len=8, ch_prefix_len=0):
    # Возвращает только имя первого файла в группе (отрезая путь до файла, а также несколько символов с начала и с конца имени)
    # group == список, содержащий полные пути до файлов группы

def combine_wfm_to_csv(dir_path,            # путь до wfm файлов
                   save_to=None,            # путь, куда надо сохранять  .csv файлы
                   files_in_group=4,        # количество файлов в каждом выстреле
                   ch_postfix_len=8,        # количество "ненужных" символов в конце имени файла (например "_Ch1.wfm"), 
                   delimiter=", ",          # разделитель столбцов в выходных .csv файлах
                   target_ext=".wfm",       # разширение файлов, которые надо считать
                   save_with_ext=".CSV",    # разширение файлов, с которым надо сохранить
                   silent_mode=False):      # отколючить уведомления в командной строке (по умолчанию включены)

    # Считывает wfm файлы, относящиеся к одному выстрелу, и сохраняет данные в едином .csv файле
    # На выходе получается по одному .csv файлу на выстрел


def combine_tds2024c_csv(dir_path,          # путь до исходных файлов
                     save_to=None,          # путь, куда надо сохранять объединенные .csv файлы
                     files_in_group=4,      # количество файлов в каждом выстреле
                     ch_postfix_len=7,      # количество "ненужных" символов в конце имени файла (например "CH1.CSV"), 
                     skip_header=18,        # пропук первых строк исходных файлов (сопутствующая информация)
                     usecols=(3, 4),        # считывать только указанные столбцы в исходных файлах т.к. первые три столбца пустые (без значений)
                     delimiter=", ",        # разделитель столбцов в выходных .csv файлах
                     target_ext=".CSV",     # разширение файлов, которые надо считать
                     save_with_ext=".CSV",  # разширение файлов, с которым надо сохранить
                     silent_mode=False):    # отколючить уведомления в командной строке (по умолчанию включены)
    
    # Считывает csv файлы, относящиеся к одному выстрелу, и сохраняет данные в едином .csv файле
    # На выходе получается по одному .csv файлу на выстрел

def combine_hmo3004_csv(dir_path,           # путь до исходных файлов
                    save_to=None,           # путь, куда надо сохранять объединенные .csv файлы
                    files_in_group=1,       # количество файлов в каждом выстреле
                    ch_postfix_len=4,       # количество "ненужных" символов в конце имени файла (например ".CSV"), 
                    skip_header=1,          # пропук первых строк исходных файлов (сопутствующая информация)
                    usecols=tuple(),        # считывать только указанные столбцы в исходных файлах (по умолчанию все)
                    delimiter=", ",         # разделитель столбцов в выходных .csv файлах
                    target_ext=".CSV",      # разширение файлов, которые надо считать
                    save_with_ext=".CSV",   # разширение файлов, с которым надо сохранить
                    silent_mode=False):     # отколючить уведомления в командной строке (по умолчанию включены)
    
    # Считывает csv файлы, относящиеся к одному выстрелу, и сохраняет данные в едином .csv файле
    # На выходе получается по одному .csv файлу на выстрел

def combine_lecroy_csv(dir_path,            # путь до исходных файлов
                   save_to=None,            # путь, куда надо сохранять объединенные .csv файлы
                   files_in_group=4,        # количество файлов в каждом выстреле
                   ch_postfix_len=4,        # количество "ненужных" символов в конце имени файла (например ".txt"), 
                   ch_prefix_len=3,         # количество "ненужных" символов в начале имени файла (например "C1_"), 
                   skip_header=5,           # пропук первых строк исходных файлов (сопутствующая информация)
                   usecols=tuple(),         # считывать только указанные столбцы в исходных файлах (по умолчанию все)
                   delimiter=", ",          # разделитель столбцов в выходных .csv файлах
                   target_ext=".txt",       # разширение файлов, которые надо считать
                   save_with_ext=".CSV",    # разширение файлов, с которым надо сохранить
                   silent_mode=False):      # отколючить уведомления в командной строке (по умолчанию включены)
    
    # Считывает txt файлы, относящиеся к одному выстрелу, и сохраняет данные в едином .csv файле
    # На выходе получается по одному .csv файлу на выстрел

def add_new_dir_to_path(old_leaf_dir, new_parent_dir):
    # old_leaf_dir      == полный путь до папки с исходными данными (файлами по серии)
    # new_parent_dir    == полный путь до папки с выходными данными (папками, по одной на серию/дату)
    # В папке new_parent_dir создает новую подпапку с именем old_leaf_dir

def add_zeros_to_filename(full_path, count):
    # Добывляет нули в начало порядкового номера файла, чтобы его количесто символов стало равным count
    # Например, из "C:\Data\ERG06.CSV" можно получить "C:\Data\ERG0006.CSV", если задать count=4
    # ВАЖНО: в имена файла не должно быть никаких других цифр, кроме порядкового номера!

def read_csv_group(group_of_files,
               delimiter=",",       # Default = ","
               skip_header=18,      # Defaults: TDS2024C = 18  |  HMO3004 = 1  |  LeCroy = 5  |  EasyScope = 0
               usecols=tuple()):    # Default:  tuple()   |   TDS2024C = (3, 4)
    # Считывает данные из указанных фалов (которые относятся к одному выстрелу)
    # Возвращает данные в виде таблицы numpy.ndarray

def compare_2_files(first_file_name, second_file_name, lines=10):
    # Проверяет два текстовых файла на совпадение первых нескольких строк (по умолчанию 10)
    # Возвращает: True в случае совпадения, False в случае несоответствия

def compare_files_in_folder(path, ext=".CSV"):
    # Проверяет на совпадение попарно все соседние по списку файлы с указанным разширением в указанной папке.
    # В случае совпадения выводит в консоль имена файлов с одинаковым содержимым.

def compare_files_in_subfolders(path, ext=".CSV"):
    # Запускает функцию compare_files_in_folder для каждой подпапки в указонной папке.

def add_to_log(s, print_to_console=True):
    # Возвращает сообщение и печатает его в консоле. Не добавляет разрыв строки в конце! 

def get_max_min_from_file_cols(file_list,   # список файлов с данными
                           col_list,        # список индексов столбцов, которые необходимо проверить (индекс начинается с 0)
                           col_corr=list(), # список поправочных коэффициентов к столбцам из списка col_list
                           delimiter=',',   # разделитель столбцов в CSV файлах
                           skip_header=0,   # пропук первых строк исходных файлов (сопутствующая информация)
                           verbose_mode=True):   # выводить в процессе выполнения информацию в консоль или нет
    # Для каждого файла из списка:
    #   Считывает данные из указанных столбцов (индекс начинается с 0) CSV файла
    #   Находит максимальное и минимальное значение для каждого столбца
    #   Домножает получанные значения на поправочные коэффициенты (col_corr) 
    #   (первый участвующий в обработке столбец домножается на первый коэффициент в списке col_corr, второй на второй и т.д.)
    # Выводит на экран максимальные и минимальные значения столбца с учетом поправочных коэффициентов и без
    # Выводит в конце лога максимальное и минимальное значение среди всех файлов (отдельно для каждого столбца)
    # Возвращает полный лог в виде строки

def get_max_min_from_dir(dir_path,    # полный или относительный путь к папке
                     col_list,        # список индексов столбцов, которые необходимо проверить (индекс начинается с 0)
                     col_corr=list(), # список поправочных коэффициентов к столбцам из списка col_list
                     ext='.CSV',      # разширение файлов с данными
                     delimiter=',',   # разделитель столбцов в CSV файлах
                     skip_header=0,   # пропук первых строк исходных файлов (сопутствующая информация)
                     log_file_name='log.txt',   # имя выходного файла с информацией по максимальным и минимальным значениям
                     verbose_mode=True):        # выводить в процессе выполнения информацию в консоль или нет
    # Для папки dir_path:
    #   Формирует список фалов с заданным разрешением
    #   Запускает функцию get_max_min_from_file_cols
    #   Сохраняет полученный лог в файл


# ====================================================================================================================
# ------     В РАЗРАБОТКЕ     ----------------------------------------------------------------------------------------
# ====================================================================================================================

def col_and_param_number_check(data,        # 
                               param_list): # 
    # Проверяет количество элементов списка param_list и количество столбцов двумерного массива data на эквивалентность
    # В случае эквивалентности возвращает True
    # В случае несовпадения бросает исключение IndexError

def multiplier_and_delay(data,          # двумерный массив (таблица) с данными (numpy.ndarray)
                         multiplier,    # список множителей (по одному для каждого столбца с данными)
                         delay):        # список вычитаемых (по одному для каждого столбца с данными)
    # Принимает на вход таблицу (двумерный массив) с данными (numpy.ndarray)
    #   Сначала домножает числа в столбцах на соответствующий multiplyer из списка
    #   Затем вычитает delay (свое вычитаемое для каждого столбца). Вычитаемое должно быть представлено в итоговой размерности данных столбца.
    # Возвращает измененную таблицу с данными (изменяет исходный объект и возвращает его)

def smooth_voltage(x,   # Одномерный массив времени (типа numpy.ndarray)
                   y):  # Одномерный массив значений (типа numpy.ndarray)
    # Принимает на вход два одномерных массива (время и значение)
    # Возврыщает сглаженную кривую (массив значений y_smoothed)
    # Параметры оптимизированы для сглаживания кривой напряжения (необходимо для последующего автоматического анализа его переднего фронта)

def find_voltage_front(x,                   # Одномерный массив времени (типа numpy.ndarray)
                       y,                   # Одномерный массив значений (типа numpy.ndarray)
                       level=-0.2,          # Уровень (значение на оси 'y'), превышение которого необходимо найти
                       is_positive=False):  # Полярность кривой (True == положительная; False == отрицательная)
    # Находит передний фронт напряжения (или любой другой кривой 'y')
    # Возвращает момент времени (число), в котором значение напряжения выходит за уровень (level)
